// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/* 
---------------------------------------------------------------
DYMX TOKEN - RWA Utility Token
Issued by DYM (Do Your Money)
Website: https://www.dymx.io
Whitepaper: https://dymx.io/whitepaper.pdf
Network: Binance Smart Chain (BEP-20)
Contract Address: 0x48eB58E9dd1eaD118b1246D9De0Ea41A715AaDbB
---------------------------------------------------------------

DYMX is an RWA (Real World Asset) utility token that connects 
real-world financial performance with blockchain value. 
The token is backed by the profits generated by DYM’s 
AI-driven trading systems in the global Forex market.

Part of the company’s verified profits is periodically 
allocated to DYMX buybacks and token burns, directly 
impacting the token’s market value and maintaining a 
deflationary and sustainable ecosystem.

The DYMX token is fully decentralized, with no tokens 
reserved for founders, ensuring full alignment between 
the company and the community.
---------------------------------------------------------------
*/

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }
}

contract DYMX is IERC20 {
    using SafeMath for uint256;

    string public constant name = "DYMX";
    string public constant symbol = "DYMX";
    uint8 public constant decimals = 18;
    uint256 private _totalSupply = 1_000_000_000 * 10**uint256(decimals);

    address public owner;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    // Taxes
    uint256 public burnTax = 5;      // 0.5%
    uint256 public liquidityTax = 5; // 0.5%
    uint256 public marketingTax = 10; // 1%
    uint256 public growthTax = 50;    // 5%
    uint256 public constant TAX_DIVISOR = 1000; // for precision (7% total = 70 / 1000)

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        owner = msg.sender;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call");
        _;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner_, address spender) public view override returns (uint256) {
        return _allowances[owner_][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "Transfer from zero");
        require(recipient != address(0), "Transfer to zero");
        require(amount > 0, "Amount must be > 0");

        _balances[sender] = _balances[sender].sub(amount);

        // 7% total tax (0.5% burn + 0.5% liquidity + 1% marketing + 5% growth)
        uint256 taxAmount = amount.mul(70).div(1000);
        uint256 transferAmount = amount.sub(taxAmount);

        _balances[recipient] = _balances[recipient].add(transferAmount);
        emit Transfer(sender, recipient, transferAmount);
    }

    function _approve(address owner_, address spender, uint256 amount) internal {
        require(owner_ != address(0), "Approve from zero");
        require(spender != address(0), "Approve to zero");
        _allowances[owner_][spender] = amount;
        emit Approval(owner_, spender, amount);
    }

    // Ownership transfer
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "New owner is zero");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
